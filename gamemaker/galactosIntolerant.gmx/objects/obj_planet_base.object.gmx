<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>self.radius = global.sun_radius + (self.orbit * global.orb_width);

//--------------------------------------------------------- TURNS
if (global.action_lock = 0 &amp;&amp; global.turn == self.turn)
{
    // work out the steps
    self.turn += 1;
    new_step = self.step + self.rate;

    // run the calc script
    return_arr = sci_calculateMove( self.orbit, self.step, new_step );
    self.current_degrees = return_arr[0];
    self.end_degrees = return_arr[1];
    self.move_deg = return_arr[2];
    self.move_incr = return_arr[3];

    // store new step
    self.step = new_step;
    global.turn_lock = 1;
}

// show info text on hover
if (position_meeting(mouse_x, mouse_y, id))
    showtext = 1;
else 
    showtext = 0; 

//--------------------------------------------------------- ACTIONS

if(self.do_action != -1)
{
    if (self.do_action == 1) // move back
    {
        // work out the steps
        new_step = self.step - self.rate;
    
        // run the calc script
        return_arr = sci_calculateMove( self.orbit, self.step, new_step );
        self.current_degrees = return_arr[0];
        self.end_degrees = return_arr[1];
        self.move_deg = return_arr[2];
        self.move_incr = return_arr[3];

        // store new step
        self.step = new_step;
        self.do_action = -1;
        global.action_lock = 1;
        global.arrows_visible = 0;
        global.turn +=1;
    }
    else if (self.do_action == 0) // move forward
    {
        // work out the steps
        new_step = self.step + self.rate;
    
        // run the calc script
        return_arr = sci_calculateMove( self.orbit, self.step, new_step );
        self.current_degrees = return_arr[0];
        self.end_degrees = return_arr[1];
        self.move_deg = return_arr[2];
        self.move_incr = return_arr[3];
    
        // store new step
        self.step = new_step;
        self.do_action = -1;
        global.action_lock = 1;
        global.arrows_visible = 0;
        global.turn +=1;
    }
    
}

//--------------------------------------------------------- ANIMATION
if (self.move_deg != 0)
{
    // Calculate degrees of movement for this step
    self.current_degrees += self.move_incr;
    self.move_deg -= self.move_incr;
    
    // get the current radius
    
    /// set the positions
    self.x = (room_width/2)  + (self.radius * (sin(degtorad(global.offset + self.current_degrees))));
    self.y = (room_height/2) + (self.radius * (cos(degtorad(global.offset + self.current_degrees))));
    
    //if this is the last step of animation, turn off the lock
    if self.move_deg == 0
    {
        global.turn_lock = 0;
        global.action_lock = 0;
    }
    
    // roate planet and set facing
    self.image_angle += self.day_cycle;
    
    
}

//--------------------------------------------------------- POST-ANIMA

self.facing = point_direction(room_width/2, room_height/2, self.x, self.y);









</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// display arrows if there aren't any open already
// otherwise trigger planet swap


if (global.arrows_visible == 0 &amp;&amp; global.action_lock == 0 &amp;&amp; global.turn_lock == 0) 
{
    //show_debug_message("sprite size: "+string(sprite_width)+" "+string(sprite_height));
    //show_debug_message("pos: "+string(x)+" "+string(y));
    
    r = sprite_width * 0.5;
    ang = id.facing;
    //ang=0;
    show_debug_message("angle: "+string(ang));
    
    inst0 = instance_create( x, y, obj_arrow_base );
    inst1 = instance_create( x, y, obj_arrow_base );
    inst2 = instance_create( x, y, obj_arrow_base );
    inst3 = instance_create( x, y, obj_arrow_base );
    
    inst0.parentid = id;
    inst1.parentid = id;
    inst2.parentid = id;
    inst3.parentid = id;
    
    inst0.image_angle = ang+90;
    inst1.image_angle = ang-90;
    inst2.image_angle = ang;
    inst3.image_angle = ang-180;
    
    inst0.sprite_index = global.spr_arrow_arr[0];
    inst1.sprite_index = global.spr_arrow_arr[1];
    inst2.sprite_index = global.spr_arrow_arr[2];
    inst3.sprite_index = global.spr_arrow_arr[3];
    
    inst0.type = 0; // left
    inst1.type = 1; // right
    inst2.type = 2; // up 
    inst3.type = 3; // down
}
else
{
    show_debug_message("TODO: planet swap");
    // test if up/down arrow is activated -&gt; otherwise ignore?/close arrows?
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var degrees = global.orbit_deg_arr[self.orbit] * self.step
var radius = global.sun_radius + (self.orbit * global.orb_width)
self.x = (room_width/2) + (radius * (sin(degtorad(global.offset + degrees))))
self.y = (room_height/2) + (radius * (cos(degtorad(global.offset + degrees))))

// move/swap planet [-1-off; 0-left, 1-right, 2-up, 3-down]
self.do_action = -1;

// hover info text
showtext = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

if (showtext == 1)
{
    draw_text(x, y-64, "Hi!#This is information for:#"+object_get_name(id.object_index));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
