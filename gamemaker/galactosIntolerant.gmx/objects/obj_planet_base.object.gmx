<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>self.radius = global.sun_radius + (self.orbit * global.orb_width);

// show info text on hover
if (position_meeting(mouse_x, mouse_y, id))
    showtext = 1;
else 
    showtext = 0; 

//--------------------------------------------------------- ACTIONS

if(self.do_action == 0 || self.do_action == 1)
{
    // work out the steps
    if (self.do_action == 0) // move forward
    {
        new_step = self.step + self.rate;
    }
    else if (self.do_action == 1) // move back
    {
        new_step = self.step - self.rate;
    }
    // run the calc script
    return_arr = sci_calculateMove( self.orbit, self.step, new_step );
    self.current_degrees = return_arr[0];
    self.end_degrees = return_arr[1];
    self.move_deg = return_arr[2];
    self.move_incr = return_arr[3];

    // store new step
    self.step = new_step;
    self.do_action = -1;
    global.action_lock = 1;
}

//--------------------------------------------------------- TURNS
if (global.action_lock = 0 &amp;&amp; global.turn == self.turn)
{
    // work out the steps
    self.turn += 1;
    new_step = self.step + self.rate;

    // run the calc script
    return_arr = sci_calculateMove( self.orbit, self.step, new_step );
    self.current_degrees = return_arr[0];
    self.end_degrees = return_arr[1];
    self.move_deg = return_arr[2];
    self.move_incr = return_arr[3];

    // store new step
    self.step = new_step;
    global.turn_lock = 1;
}

//--------------------------------------------------------- ANIMATION
if (self.move_deg != 0)
{
    // Calculate degrees of movement for this step
    self.current_degrees += self.move_incr;
    self.move_deg -= self.move_incr;
    
    // get the current radius
    
    /// set the positions
    self.x = (room_width/2) + global.offset_x + (self.radius * (sin(degtorad(global.offset_rotation + self.current_degrees))));
    self.y = (room_height/2)+ global.offset_y + (self.radius * (cos(degtorad(global.offset_rotation + self.current_degrees))));
    
    //if this is the last step of animation, turn off the lock
    if self.move_deg == 0
    {
        if (global.action_lock)
            global.turn +=1;
        
        global.turn_lock = 0;
        global.action_lock = 0;     
    }
    
    // roate planet and set facing
    self.image_angle += self.day_cycle;
}

//--------------------------------------------------------- POST-ANIMA

self.facing = point_direction(obj_sun.x, obj_sun.y, self.x, self.y);









</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//--------------------------------------------------------- ARROW DISPLAY

// display arrows if there aren't any open already
// otherwise trigger planet swap
if (global.arrows_visible == 0 &amp;&amp; global.swap_mode == 0 &amp;&amp; global.action_lock == 0 &amp;&amp; global.turn_lock == 0) 
{  
    r = sprite_width * 0.5;
    ang = id.facing;
    
    // forward
    inst0 = instance_create( x, y, obj_arrow_base );
    inst0.parentid = id;
    inst0.image_angle = ang+90;
    inst0.sprite_index = global.spr_arrow_arr[0];
    inst0.type = 0; // left
    
    // back
    inst1 = instance_create( x, y, obj_arrow_base );
    inst1.parentid = id;
    inst1.image_angle = ang-90;
    inst1.sprite_index = global.spr_arrow_arr[1];
    inst1.type = 1; // right
    
    // swapping
    if (id.orbit != 5)
    {
        inst2 = instance_create( x, y, obj_arrow_base );
        inst2.parentid = id;
        inst2.image_angle = ang;
        inst2.sprite_index = global.spr_arrow_arr[2];
        inst2.type = 2; // up 
    }
    
    if (id.orbit != 0)
    {
        inst3 = instance_create( x, y, obj_arrow_base );
        inst3.parentid = id;
        inst3.image_angle = ang-180;
        inst3.sprite_index = global.spr_arrow_arr[3];
        inst3.type = 2; // down
    }
}
else
{
    show_debug_message("TODO: planet swap");
    // test if up/down arrow is activated -&gt; otherwise ignore?/close arrows?
}

//--------------------------------------------------------- SWAPPING 

if (global.swap_mode == 1)
{
    //if (global.swap_from == self.id)
    //    return
    
    show_debug_message("print swap from id   :   " + string(global.swap_from));
    show_debug_message("print swap from orbit:   " + string(global.swap_from.orbit));
        
    my_orbit = self.orbit
    my_step  = self.step
    
    self.orbit = global.swap_from.orbit;
    self.step  = global.swap_from.step;
    
    global.swap_from.orbit = my_orbit;
    global.swap_from.step  = my_step ;
    
    // swap self
    degrees = global.orbit_deg_arr[self.orbit] * self.step;
    radius = global.sun_radius + (self.orbit * global.orb_width);
    self.x = (room_width/2)+global.offset_x + (radius * (sin(degtorad(global.offset_rotation + degrees))));
    self.y = (room_height/2)+global.offset_y + (radius * (cos(degtorad(global.offset_rotation + degrees))));
    
    // swap remote
    var degrees = global.orbit_deg_arr[global.swap_from.orbit] * global.swap_from.step;
    var radius = global.sun_radius + (global.swap_from.orbit * global.orb_width);
    global.swap_from.x = (room_width/2)+global.offset_x + (radius * (sin(degtorad(global.offset_rotation + degrees))));
    global.swap_from.y = (room_height/2)+global.offset_y + (radius * (cos(degtorad(global.offset_rotation + degrees))));
      
    // cleanup
    global.swap_mode = 0;
    global.swap_from = -1;
    global.action_lock = 0;
    global.turn +=1;
}











</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// click sounds
snd = audio_play_sound(snd_click, 100, false);
audio_sound_gain(snd, global.snd_fx, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var degrees = global.orbit_deg_arr[self.orbit] * self.step
var radius = global.sun_radius + (self.orbit * global.orb_width)
self.x = (room_width/2)+global.offset_x + (radius * (sin(degtorad(global.offset_rotation + degrees))))
self.y = (room_height/2)+global.offset_y + (radius * (cos(degtorad(global.offset_rotation + degrees))))

// move/swap planet [-1-off; 0-left, 1-right, 2-up, 3-down]
self.do_action = -1;

// hover info text
showtext = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

if (showtext == 1)
{
    draw_text(x, y-64, "Hi!#This is information for:#"+object_get_name(id.object_index));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
